Master Initialization Prompt
# Photo Editing App - Complete Technical Specification
You are an expert full-stack developer. Read this entire specification carefully and acknowledge comprehension before beginning any implementation. **DO NOT start coding until I give you phased instructions.**
---
## Project Overview
Build a photo editing web application using Google's Gemini 2.5 Flash Image API (Nano Banana) for AI-powered image transformations. Users can sign up, upload images, edit them using natural language prompts, apply multiple sequential edits, view edit history, and save favorites to their personal gallery.
---
## Tech Stack
### Frontend
- **Framework:** React 18 with Vite
- **Styling:** Tailwind CSS
- **UI Components:** Shadcn UI
- **State Management:** React Query + Context API
- **File Upload:** React Dropzone
- **Image Comparison:** react-compare-image (for before/after slider)
- **HTTP Client:** Axios
### Backend
- **Runtime:** Node.js
- **Framework:** Express.js
- **Database:** PostgreSQL
- **Authentication:** Replit Auth
- **File Upload:** Multer (20MB limit)
- **Storage:** Replit Object Storage
- **AI Integration:** Google Gemini API SDK (@google/genai)
- **Image Processing:** Sharp
- **Rate Limiting:** express-rate-limit
- **Validation:** Joi or Zod
### Project Structure
- **Monorepo:** pnpm workspaces
- **Packages:** `packages/client`, `packages/server`, `packages/shared`
---
## Project File Structure

photo-editing-app/
├── pnpm-workspace.yaml
├── package.json # Root workspace config
├── .env.example
├── .replit
├── replit.nix
├── README.md
│
├── packages/
│ ├── shared/ # Shared types and constants
│ │ ├── package.json
│ │ ├── src/
│ │ │ ├── types/
│ │ │ │ ├── user.ts
│ │ │ │ ├── image.ts
│ │ │ │ ├── edit.ts
│ │ │ │ └── api.ts
│ │ │ └── constants/
│ │ │ ├── errorCodes.ts
│ │ │ └── config.ts
│ │ └── tsconfig.json
│ │
│ ├── client/ # React Frontend
│ │ ├── public/
│ │ │ └── assets/
│ │ ├── src/
│ │ │ ├── components/
│ │ │ │ ├── auth/
│ │ │ │ │ ├── AuthGuard.jsx
│ │ │ │ │ └── LoginButton.jsx
│ │ │ │ ├── upload/
│ │ │ │ │ ├── ImageUploader.jsx
│ │ │ │ │ └── UploadZone.jsx
│ │ │ │ ├── editor/
│ │ │ │ │ ├── EditorWorkspace.jsx
│ │ │ │ │ ├── ImageCanvas.jsx
│ │ │ │ │ ├── PromptInput.jsx
│ │ │ │ │ ├── EditHistory.jsx
│ │ │ │ │ ├── EditHistoryItem.jsx
│ │ │ │ │ ├── ProcessingIndicator.jsx
│ │ │ │ │ └── BeforeAfterSlider.jsx
│ │ │ │ ├── gallery/
│ │ │ │ │ ├── Gallery.jsx
│ │ │ │ │ ├── GalleryGrid.jsx
│ │ │ │ │ ├── GalleryItem.jsx
│ │ │ │ │ └── ImageDetailModal.jsx
│ │ │ │ ├── suggestions/
│ │ │ │ │ ├── PromptSuggestions.jsx
│ │ │ │ │ ├── InterviewFlow.jsx
│ │ │ │ │ └── SuggestionCard.jsx
│ │ │ │ ├── ui/ # Shadcn UI components
│ │ │ │ │ ├── button.jsx
│ │ │ │ │ ├── dialog.jsx
│ │ │ │ │ ├── card.jsx
│ │ │ │ │ ├── input.jsx
│ │ │ │ │ ├── dropdown-menu.jsx
│ │ │ │ │ ├── toast.jsx
│ │ │ │ │ └── progress.jsx
│ │ │ │ └── layout/
│ │ │ │ ├── Header.jsx
│ │ │ │ ├── Sidebar.jsx
│ │ │ │ └── Footer.jsx
│ │ │ ├── views/ # Pages (NOT "pages/")
│ │ │ │ ├── HomePage.jsx
│ │ │ │ ├── EditorPage.jsx
│ │ │ │ ├── GalleryPage.jsx
│ │ │ │ ├── OnboardingPage.jsx
│ │ │ │ └── NotFoundPage.jsx
│ │ │ ├── hooks/
│ │ │ │ ├── useAuth.js
│ │ │ │ ├── useImageUpload.js
│ │ │ │ ├── useImageEdit.js
│ │ │ │ └── useGallery.js
│ │ │ ├── services/
│ │ │ │ ├── api.js
│ │ │ │ ├── authService.js
│ │ │ │ ├── imageService.js
│ │ │ │ └── editService.js
│ │ │ ├── utils/
│ │ │ │ ├── imageUtils.js
│ │ │ │ └── promptTemplates.js
│ │ │ ├── context/
│ │ │ │ └── AuthContext.jsx
│ │ │ ├── App.jsx
│ │ │ ├── main.jsx
│ │ │ └── index.css
│ │ ├── package.json
│ │ └── vite.config.js
│ │
│ └── server/ # Express Backend
│ ├── config/
│ │ ├── database.js
│ │ ├── storage.js
│ │ └── gemini.js
│ ├── middleware/
│ │ ├── auth.js
│ │ ├── upload.js
│ │ ├── rateLimiter.js
│ │ └── errorHandler.js
│ ├── routes/
│ │ ├── v1/ # API v1
│ │ │ ├── auth.routes.js
│ │ │ ├── images.routes.js
│ │ │ ├── edits.routes.js
│ │ │ ├── gallery.routes.js
│ │ │ └── preferences.routes.js
│ │ └── index.js
│ ├── controllers/
│ │ ├── authController.js
│ │ ├── imageController.js
│ │ ├── editController.js
│ │ ├── galleryController.js
│ │ └── preferencesController.js
│ ├── services/
│ │ ├── geminiService.js
│ │ ├── storageService.js
│ │ └── suggestionService.js
│ ├── models/
│ │ ├── User.js
│ │ ├── Image.js
│ │ ├── Edit.js
│ │ └── UserPreference.js
│ ├── db/
│ │ ├── schema.sql
│ │ └── migrations/
│ ├── utils/
│ │ ├── validators.js
│ │ ├── imageProcessor.js
│ │ └── errorCodes.js
│ ├── server.js
│ └── package.json

---
## Database Schema (PostgreSQL)
### **users**
```sql
CREATE TABLE users (
  id                SERIAL PRIMARY KEY,
  replit_user_id    VARCHAR(255) UNIQUE NOT NULL,
  username          VARCHAR(100),
  email             VARCHAR(255),
  created_at        TIMESTAMP DEFAULT NOW(),
  updated_at        TIMESTAMP DEFAULT NOW(),
  deleted_at        TIMESTAMP DEFAULT NULL
);
CREATE INDEX idx_users_replit_id ON users(replit_user_id);
CREATE INDEX idx_users_deleted ON users(deleted_at) WHERE deleted_at IS NULL;

user_preferences
CREATE TABLE user_preferences (
  id                      SERIAL PRIMARY KEY,
  user_id                 INTEGER REFERENCES users(id) ON DELETE CASCADE,
  has_completed_interview BOOLEAN DEFAULT FALSE,
  editing_style           VARCHAR(50),
  common_use_cases        TEXT[],
  skill_level             VARCHAR(20),
  favorite_effects        TEXT[],
  created_at              TIMESTAMP DEFAULT NOW(),
  updated_at              TIMESTAMP DEFAULT NOW(),
  deleted_at              TIMESTAMP DEFAULT NULL,
  
  CONSTRAINT unique_user_preference UNIQUE(user_id)
);
CREATE INDEX idx_user_prefs_user ON user_preferences(user_id) WHERE deleted_at IS NULL;

images
CREATE TABLE images (
  id                SERIAL PRIMARY KEY,
  user_id           INTEGER REFERENCES users(id) ON DELETE CASCADE,
  original_filename VARCHAR(255) NOT NULL,
  original_url      TEXT NOT NULL,
  file_size         INTEGER NOT NULL,
  mime_type         VARCHAR(50) NOT NULL,
  width             INTEGER,
  height            INTEGER,
  uploaded_at       TIMESTAMP DEFAULT NOW(),
  has_edits         BOOLEAN DEFAULT FALSE,
  metadata          JSONB,
  deleted_at        TIMESTAMP DEFAULT NULL
);
CREATE INDEX idx_images_user ON images(user_id, uploaded_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_images_has_edits ON images(user_id, has_edits) WHERE deleted_at IS NULL AND has_edits = TRUE;
CREATE INDEX idx_images_deleted ON images(deleted_at) WHERE deleted_at IS NOT NULL;

edits
CREATE TABLE edits (
  id                  SERIAL PRIMARY KEY,
  image_id            INTEGER REFERENCES images(id) ON DELETE CASCADE,
  user_id             INTEGER REFERENCES users(id) ON DELETE CASCADE,
  prompt_used         TEXT NOT NULL,
  edited_url          TEXT NOT NULL,
  is_saved_to_gallery BOOLEAN DEFAULT FALSE,
  edit_order          INTEGER NOT NULL,
  processing_time_ms  INTEGER,
  created_at          TIMESTAMP DEFAULT NOW(),
  deleted_at          TIMESTAMP DEFAULT NULL
);
CREATE INDEX idx_edits_image ON edits(image_id, edit_order) WHERE deleted_at IS NULL;
CREATE INDEX idx_edits_gallery ON edits(user_id, is_saved_to_gallery, created_at DESC) WHERE deleted_at IS NULL AND is_saved_to_gallery = TRUE;
CREATE INDEX idx_edits_created ON edits(created_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_edits_deleted ON edits(deleted_at) WHERE deleted_at IS NOT NULL;

prompt_suggestions (Optional - Pre-seeded)
CREATE TABLE prompt_suggestions (
  id                SERIAL PRIMARY KEY,
  category          VARCHAR(50) NOT NULL,
  prompt_text       TEXT NOT NULL,
  description       TEXT,
  example_image_url TEXT,
  popularity_score  INTEGER DEFAULT 0,
  is_active         BOOLEAN DEFAULT TRUE,
  created_at        TIMESTAMP DEFAULT NOW()
);
CREATE INDEX idx_suggestions_category ON prompt_suggestions(category, popularity_score DESC) WHERE is_active = TRUE;

API Endpoints (All prefixed with /api/v1/)
Authentication
GET  /api/v1/auth/me              - Get current user
POST /api/v1/auth/logout          - Logout

User Preferences
GET  /api/v1/preferences          - Get user preferences
POST /api/v1/preferences          - Create/update preferences (interview)

Images
POST /api/v1/images/upload        - Upload image (max 20MB)
GET  /api/v1/images/:id           - Get image details
GET  /api/v1/images               - Get user images (cursor-based pagination)
DELETE /api/v1/images/:id         - Soft delete image

Edits
POST /api/v1/edits                - Create new edit (AI transformation)
GET  /api/v1/edits/image/:imageId - Get all edits for image (cursor-based)
PATCH /api/v1/edits/:id/save      - Mark edit as saved to gallery
DELETE /api/v1/edits/:id          - Soft delete edit

Gallery
GET  /api/v1/gallery              - Get saved edits (cursor-based pagination)
GET  /api/v1/gallery/:editId      - Get specific edit with original

Suggestions
GET  /api/v1/suggestions          - Get personalized prompts
GET  /api/v1/suggestions/popular  - Get popular prompts

Core Features & User Flows
1. User Onboarding
User signs up via Replit Auth
Redirect to /onboarding
Short interview: editing style, use cases, skill level
Save to user_preferences table
Generate personalized prompt suggestions
Redirect to /editor
2. Image Upload
User drags/drops or selects image (max 20MB)
Frontend validates: size, format (JPEG, PNG, WebP)
POST /api/v1/images/upload (multipart/form-data)
Backend:
Saves to Object Storage
Extracts EXIF metadata (Sharp)
Creates images record (has_edits=false)
Return image object
Frontend displays in editor workspace
3. AI-Powered Editing (Sequential)
User enters text prompt: "make the sky more dramatic"
POST /api/v1/edits with {image_id, prompt_used}
Backend:
Fetches latest version (original or last edit)
Calls Gemini 2.5 Flash Image API
Saves edited image to Object Storage
Creates edits record (edit_order incremented)
Updates images.has_edits = true
Return edited image URL
Frontend:
Displays BeforeAfterSlider (original vs edited)
Adds to EditHistory sidebar
User can apply another edit → repeats process (edit_order+=1)
4. Edit History
GET /api/v1/edits/image/:imageId?cursor=...&limit=20
Backend returns edits with cursor-based pagination
Frontend displays:
Thumbnail of each edit
Prompt used
"Save to gallery" button
"Use as base" button (for sequential editing)
5. Save to Gallery
User clicks "Save" on preferred edit
PATCH /api/v1/edits/:id/save → is_saved_to_gallery = true
Edit now appears in /gallery
6. Gallery View
GET /api/v1/gallery?cursor=...&limit=20
Backend returns saved edits with cursor pagination
Frontend displays:
Infinite scroll or "Load more"
Each item shows BeforeAfterSlider
Click → ImageDetailModal (full-size, download)
7. Prompt Suggestions
GET /api/v1/suggestions (personalized based on user_preferences)
Backend:
Reads user_preferences.common_use_cases, editing_style
Returns relevant prompts from prompt_suggestions table
Or generates dynamic suggestions using Gemini
Frontend displays as clickable cards
Click → auto-fills PromptInput
Cursor-Based Pagination Implementation
Backend Pattern
async function getCursorPaginatedEdits(userId, cursor, limit = 20) {
  let query = `
    SELECT * FROM edits 
    WHERE user_id = $1 
    AND is_saved_to_gallery = true
    AND deleted_at IS NULL
  `;
  
  const params = [userId];
  
  if (cursor) {
    query += ` AND created_at < $${params.length + 1}`;
    params.push(cursor);
  }
  
  query += ` ORDER BY created_at DESC LIMIT $${params.length + 1}`;
  params.push(limit + 1);
  
  const results = await db.query(query, params);
  
  const hasMore = results.rows.length > limit;
  const items = hasMore ? results.rows.slice(0, -1) : results.rows;
  const nextCursor = hasMore ? items[items.length - 1].created_at : null;
  
  return { items, nextCursor, hasMore };
}

Frontend Pattern
function useInfiniteGallery() {
  const [items, setItems] = useState([]);
  const [cursor, setCursor] = useState(null);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(false);
  
  const loadMore = async () => {
    setLoading(true);
    const url = cursor 
      ? `/api/v1/gallery?cursor=${cursor}&limit=20`
      : `/api/v1/gallery?limit=20`;
    
    const res = await fetch(url);
    const { items: newItems, nextCursor, hasMore } = await res.json();
    
    setItems(prev => [...prev, ...newItems]);
    setCursor(nextCursor);
    setHasMore(hasMore);
    setLoading(false);
  };
  
  return { items, loadMore, hasMore, loading };
}

Rate Limiting Configuration
Apply to AI Edit Endpoint
// middleware/rateLimiter.js
import rateLimit from 'express-rate-limit';
export const editRateLimiter = rateLimit({
  windowMs: 60 * 1000,        // 1 minute
  max: 10,                     // 10 requests per minute per user
  message: {
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: 'Too many edit requests. Please wait before trying again.'
    }
  },
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => req.user.id  // Rate limit per user
});
// routes/v1/edits.routes.js
router.post('/edits', editRateLimiter, editController.createEdit);

Structured Error Response Format
All API errors return:
{
  "error": {
    "code": "IMAGE_TOO_LARGE",
    "message": "File size exceeds 20MB limit",
    "details": {
      "maxSize": "20MB",
      "receivedSize": "25MB"
    }
  }
}

Error Codes (in packages/shared/constants/errorCodes.ts)
export const ErrorCodes = {
  // Authentication
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',
  
  // Images
  IMAGE_TOO_LARGE: 'IMAGE_TOO_LARGE',
  INVALID_IMAGE_FORMAT: 'INVALID_IMAGE_FORMAT',
  IMAGE_NOT_FOUND: 'IMAGE_NOT_FOUND',
  
  // Edits
  GEMINI_API_ERROR: 'GEMINI_API_ERROR',
  EDIT_PROCESSING_FAILED: 'EDIT_PROCESSING_FAILED',
  
  // Rate Limiting
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',
  
  // General
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR'
};

Soft Delete Implementation
Pattern for all delete operations:
// DON'T: Hard delete
await db.query('DELETE FROM images WHERE id = $1', [imageId]);
// DO: Soft delete
await db.query(
  'UPDATE images SET deleted_at = NOW() WHERE id = $1',
  [imageId]
);

Filter deleted records in all queries:
// Always include WHERE deleted_at IS NULL
const images = await db.query(`
  SELECT * FROM images 
  WHERE user_id = $1 
  AND deleted_at IS NULL
  ORDER BY uploaded_at DESC
`, [userId]);

Root package.json Scripts
{
  "name": "photo-editing-app",
  "private": true,
  "scripts": {
    "dev": "concurrently \"pnpm --filter server dev\" \"pnpm --filter client dev\"",
    "build": "pnpm --filter client build && pnpm --filter server build",
    "start": "pnpm --filter server start",
    
    "add:client": "pnpm --filter client add",
    "add:server": "pnpm --filter server add",
    "add:shared": "pnpm --filter shared add",
    
    "migrate": "pnpm --filter server migrate",
    "db:seed": "pnpm --filter server db:seed",
    "test": "pnpm -r test",
    "lint": "pnpm -r lint"
  },
  "devDependencies": {
    "concurrently": "^8.2.2"
  }
}

pnpm-workspace.yaml
packages:
  - 'packages/*'

Environment Variables
# Database
DATABASE_URL=postgresql://user:password@localhost:5432/photo_editing_app
# Replit Auth
REPLIT_AUTH_SECRET=your_secret_here
# Google Gemini API
GEMINI_API_KEY=your_gemini_api_key
# Object Storage
STORAGE_ENDPOINT=your_storage_endpoint
STORAGE_BUCKET=photo-editing-app
# Server
PORT=3000
NODE_ENV=development
# Frontend (for Vite)
VITE_API_URL=http://localhost:3000/api/v1

Key Design Decisions
Sequential Editing: Each edit uses the previous edit as input (tracked via edit_order)
Lazy Persistence: Images appear in gallery only after has_edits = true
Edit History: All edits stored; user chooses which to save
Soft Delete: All deletions use deleted_at timestamp
Cursor Pagination: All lists use cursor-based pagination for scalability
API Versioning: All endpoints prefixed with /api/v1/
Rate Limiting: 10 edits/minute per user
Structured Errors: All errors return { error: { code, message, details } }
Workspaces: Monorepo structure for shared code
JSONB Metadata: Flexible storage for EXIF data
TEXT[] Preferences: Simple array storage for user preferences
Next Phase Features (NOT in MVP)
Background cleanup job for files deleted >30 days ago
Many-to-many tables for use cases/effects (advanced analytics)
Structured EXIF fields for advanced filtering
Batch editing (apply prompt to multiple images)
Social sharing with privacy controls
Export functionality (ZIP download)
Advanced prompt templates library
Mobile-responsive optimizations
Progressive Web App (PWA) features
Instructions for Implementation
STOP HERE. DO NOT START CODING.

Please acknowledge that you understand:

The complete tech stack and architecture
The workspaces monorepo structure
The database schema with soft delete and cursor pagination
The API structure with /api/v1/ versioning
The core user flows (upload → edit → history → gallery)
The error handling and rate limiting requirements
That you will wait for my phased instructions before beginning implementation